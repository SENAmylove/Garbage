import copy
import os
import re
import yaml
from typing import List
from collections import OrderedDict
from functools import cmp_to_key
from typing import List

def ensure_quoted(line: str) -> str:
    """
    This func ensures that the line passed in is double-quoted
    :param
        line -> string to be double-quoted
    :return:
        string -> a double-quoted line
    """
    line = line.replace('"', '')
    line = '"' + line + '"'
    return line

def generate_dict(file_path: str) -> dict:
    """
    Generate a dict tree from the dat file, using yaml package, which means the dat file is first processed to be
    translated into a yaml-format file and then loaded with yaml package.
    :param
        file_path -> the file path of the dat file
    :return:
        dict -> a dict tree contains all values in the dat file
    """

    # Param check
    assert os.path.exists(file_path)

    # Convert file extension
    base_name = os.path.basename(file_path)
    base_dir = os.path.dirname('./yaml')
    yaml_file_name = base_name.split('.')[0] + '.yml'

    # To ensure the proper encoding of the file, it is loaded with mbcs encoding
    with open(file_path, 'r',encoding='mbcs') as reader:
        writer = open(os.path.join(base_dir,yaml_file_name), 'w', encoding='mbcs')
        while line := reader.readline():
            # Need to skip the lines that start with ";", since they are just remarks.
            if line.startswith(';') or len(line.strip()) == 0:
                # Skip the remarks
                continue

            if '\\' in line:
                # Need to convert the \ into /
                line = line.replace('\\', '/')

            if '=' in line:
                # StructName = "TypeDataGeneralStruct"
                # Like the format shown above, if current line has a "=" in it, it has no child items.
                # Then we need to translate this line into a yaml format which is <StructName : TypeDataGeneralStruct">

                # Do the split
                cols = line.split('=', 1)
                if cols[-1][-1] == '\n':
                    # Get rid of the final '\n' first, since we need to add the double-quoted mark before the '\n'
                    cols[-1] = cols[-1][:-1]
                cols[-1] = ensure_quoted(cols[-1].strip())
                # combine them using ":", which is yaml format
                writer.write(' : '.join(cols) + '\n')

            else:
                # Properties
                #   Label_D = "Allgemein"
                #   Label_E = "General"
                #   Label_P = "Geral"
                #   Label_T = "Genel"
                #   Like the format shown above, if there is no "=" in a line, it means it has child items following it.
                #   Then we need to add a ":" right before the "=" and translate it into the format below
                # Properties:
                #   Label_D = "Allgemein"
                #   Label_E = "General"
                #   Label_P = "Geral"
                #   Label_T = "Genel"

                # Some lines may contain "#" as a following remark. We need to get rid of it too.
                if '#' in line:
                    line = line[:line.find('#')]

                line = line[:-1]
                # Add the ":"
                line += ':\n'
                writer.write(line)

        # Close the file handle
        writer.close()

        # At this point, the yaml file has been attained from the dat file.

    with open(yaml_file_name, 'r', encoding = 'mbcs') as r:
        # Load the yaml file into a pyton dict
        di = yaml.safe_load(r)
        # Here we ensure that it only has one root item, as the dat files appear to have only one root.
        assert len(di.keys()) == 1
        pre_root_key = list(di.keys())[0]

        # we convert the root key into proper format
        root_key = pre_root_key.replace('/','\\')
        # replace the inital root key
        di[root_key] = di.pop(pre_root_key)
        return OrderedDict(di)

def re_order(dict_list: List[OrderedDict])-> List[OrderedDict]:
    # Get the keys
    def worker(item1: OrderedDict, item2: OrderedDict):
        item1_key = list(item1.keys())
        item2_key = list(item2.keys())

        assert len(item1_key) == 1
        assert len(item2_key) == 1

        item1_key = item1_key[0]
        item2_key = item2_key[0]

        index1 = item1_key[item1_key.index('[')+1:item1_key.index(']')]
        index2 = item2_key[item2_key.index('[')+1:item2_key.index(']')]

        if index1 < index2:
            return -1
        elif index1 > index2:
            return 1
        else:
            return 0

    return sorted(dict_list, key= cmp_to_key(worker))


def validate(content_dict: dict, depth: int = 0) -> dict:
    """
    This func validate the value ranges and put a remark <invalid> behind the invalid line.
    :param
        content_dict -> dict that contains the content
    :return:
        modified content dict
    """
    # Generate a ordered dict for contents
    ordered_content_dict = OrderedDict()

    if not isinstance(content_dict, dict):
        return {}

    for _key, _item in content_dict.items():

        ## Check the value range if the dict has the ValueRange property
        if 'ValueRange' in _key:
            _val_range = content_dict['ValueRange'].strip()
            _val_range = _val_range[_val_range.index('[') + 1: _val_range.index(']')]
            _lower_bound = float(_val_range.split(';')[0])
            _upper_bound = float(_val_range.split(';')[-1])
            if float(content_dict['Data']) < _lower_bound or float(content_dict['Data']) > _upper_bound:
                content_dict['Data'] = content_dict['Data'] + ' INVALID VALUE'

        if 'SelectValues_D' in _key:
            assert 'SelectValues_E' in content_dict.keys()
            if len(content_dict['SelectValues_D'].strip()) == 0 and len(content_dict['SelectValues_E'].strip()) == 0:
                content_dict['SelectValues_D'] += ' INVALID EMPTY SELECT VALUES'

        _temp_result = validate(_item, depth+1)

        _key_array = []
        # If array is found
        if re.match(r'\[[0-9]+\]', _key) is not None:
            print(f'Array key found: {_key}')
            _key_array.append(OrderedDict({_key:_temp_result}))
        else:
            if len(_temp_result) > 0:
                content_dict[_key] = _temp_result


        _key_array = re_order(_key_array)
        for _temp_dict in _key_array:
            for _key, _item in _temp_dict:
                ordered_content_dict[_key] = _item

        ####

    return content_dict

def extract(content_dict: dict, keys: List[str], result) -> dict:
    """
    This func uses a recursive calling convention to traverse the whole dict
    :param
        content_dict -> the dict that contains the content loaded from the attained yaml file
    :param
        keys -> the keys we want to extract
    :param
        result -> the dict that contains extracted items
    :return:
        it returns the result dict
    """
    assert len(keys) > 0

    # BASE CONDITION !
    # The BASE CONDITION is the condition in which the recursive calling would end.
    # Here, the recursive calling would call an end if it encounters a leaf ( a node without any child items)
    if not isinstance(content_dict, dict):
        return {}

    for _count_key in keys:
        if _count_key in content_dict.keys():
            # If we encounter with a key that we want to extract, then it is put into the result dict.
            result[_count_key] = content_dict[_count_key]
        else:
            for _count_child_key, _count_child_val in content_dict.items():
                # If no interesting keys exists, we do the recursive calling to search in its child items
                _temp_result = extract(_count_child_val, keys, result)
                if len(_temp_result) > 0:
                    # Only put it into the result if it is not empty
                    result.update(_temp_result)

    return result


def filter_out(content_dict: dict, keys: List[str]) -> dict:
    """
        This func is a reverse one for the extract func. Instead of extracting something we want, we filter out
        something we don't want.

    :param
        content_dict -> the dict that contains the content from the yaml file.
    :param
        keys -> keys list we don't want
    :return
        the filterd dict
    """
    assert len(keys) > 0

    if not isinstance(content_dict, dict):
        return {}

    for _count_key in keys:
        if _count_key in content_dict.keys():
            content_dict.pop(_count_key)
        else:
            for _count_child_key, _count_child_val in content_dict.items():
                filter_out(_count_child_val, keys)

def process(file_path: str):

    base_name = os.path.basename(file_path)
    base_dir_extracted = './extracted'
    base_dir_filtered = './filtered'

    if not os.path.exists(base_dir_extracted):
        os.makedirs(base_dir_extracted)
    if not os.path.exists(base_dir_filtered):
        os.makedirs(base_dir_filtered)

    # result_yaml_name = base_name.split('.')[0] + '_extracted.yml'
    result_dat_name = base_name.split('.')[0] + '.dat'
    # result_filtered_yaml_name = base_name.split('.')[0] + '_filtered.dat'
    result_filtered_dat_name = base_name.split('.')[0] + '.dat'

    converted_dict = generate_dict(file_path)
    filtered_dict = copy.deepcopy(converted_dict)

    converted_dict = validate(converted_dict, 0)
    filtered_dict = validate(filtered_dict, 0)

    keys = ['WOffsetTank','MQKorrFU1', 'MQKorrFU2','TZeitSc','TMaxMengeSc']
    result = extract(converted_dict, keys, {})
    filter_out(filtered_dict,keys)
    result = {'\$OpConTemp\\1\DataEditFU1': result}

    dat_extracted_writer = open(os.path.join(base_dir_extracted,result_dat_name),'w', encoding='mbcs')
    dat_filtered_writer = open(os.path.join(base_dir_filtered,result_filtered_dat_name),'w', encoding='mbcs')

    output_dict(result,dat_extracted_writer,0)
    output_dict(filtered_dict,dat_filtered_writer,0)

    dat_extracted_writer.close()
    dat_filtered_writer.close()

def output_dict(result: dict, writer, indent = 0):
    """
        Traverse the whole dict tree, and print out them in dat format.
    :param
        result -> the dict that needs to be printed
    :param
        writer -> the file handle
    :param
        indent -> the indent for current calling
    :return:
        returns nothing
    """
    assert writer is not None

    for _key, _val in result.items():
        if type(_val) == dict:
            writer.write(' '*2*indent + _key + '\n')
            output_dict(_val, writer, indent + 1)
        else:
            if _val.startswith('REG_'):
                # "Security = REG_DWORD 0x102" this kind of line requires no double-quoted
                # ' ' * 2 * indent stands for the indent
                writer.write(' ' * 2 * indent + _key + ' = ' + _val + '\n')
            else:
                # convert into Label_D = "Allgemein" foramt
                writer.write( ' ' * 2 * indent + _key + ' = ' + '"' + _val + '"' + '\n')

if __name__ == '__main__':

    root = './'
    file_list = os.listdir(root)
    for _count_file in file_list:
        if '_extracted' not in _count_file and _count_file.endswith('.dat'):
            process(_count_file)












