import numpy as np
import pandas as pd
from scipy.spatial import distance
from fastdtw import fastdtw
from functools import partial
from datetime import datetime
from typing import List, Set, Union
import os


def prepare_trace(id: str, start_time: str, end_time: str, file_path: str) -> np.array:
    assert os.path.exists(file_path)

    _resulted_trace = []

    with open(file_path, 'r') as reader:
        contents = reader.readlines()

    for _line_index, _line in enumerate(contents):
        _cols = _line.split(',')
        _current_id = _cols[0]
        _current_time = _cols[3]
        if int(_line.split(',')[0]) == int(id) and int(_current_time) >= int(start_time) and int(_current_time) <= int(
                end_time):
            _inserted = np.array([float(_val) for _col_index, _val in enumerate(_cols) if _col_index in [4, 5, 11, 12]])

            if _line_index >= 1:
                _previous_pos = [float(_p) for _p in contents[_line_index - 1].split(',')[4:6]]
                _current_pos = [float(_p) for _p in _cols[4:6]]
                _direction = np.array(_current_pos) - np.array(_previous_pos)
                _direction = _direction / np.linalg.norm(_direction)
                _inserted = np.append(_inserted, _direction)
            else:
                _inserted = np.append(_inserted, np.array([0.0, 0.0]))

            _resulted_trace.append(_inserted)

    return _resulted_trace


def generate_dtw_distance(trace1: List[Union[float, List[float]]], trace2: List[Union[float, List[float]]]):
    assert len(trace1) > 0
    assert len(trace2) > 0

    def worker(pos1: np.array, pos2: np.array):
        _total_euclidean_distance = 0.0
        _total_euclidean_distance += np.sum((pos1[0:4] - pos2[0:4]) ** 2)
        _total_euclidean_distance += distance.euclidean(pos1[4:], pos2[4:])
        return _total_euclidean_distance

    # prepare two traces
    return fastdtw(trace1, trace2, dist=worker)


def get_density_metric(file_path):
    assert os.path.exists(file_path)

    with open(file_path, 'r') as reader:
        # print(train_file_path)
        content = np.array([x.strip().split(',') for x in reader.readlines()]).astype(float)
        now_dict = {}
        for row in content:
            n_dict = now_dict.get(row[1], {})
            n_dict[row[0]] = row  # [2:]
            now_dict[row[1]] = n_dict
    density = []
    for _frame_id, _vehs in now_dict.items():
        density.append((_frame_id, len(_vehs)))
    density = sorted(density, key=lambda den: den[0])

    avg_density = 0
    for (_frame_id, _den) in density:
        avg_density += _den
    avg_density = avg_density / len(density)

    return density, avg_density


def get_veh_metrics(file_path):
    assert os.path.exists(file_path)
    with open(file_path, 'r') as reader:
        contents = reader.readlines()

    vehicle_dict = {}
    start_timestamp = int(contents[0].split(',')[3])
    end_timestamp = start_timestamp
    for _line in contents:
        cols = _line.split(',')
        if int(cols[3]) < start_timestamp:
            start_timestamp = int(cols[3])

        if int(cols[3]) > end_timestamp:
            end_timestamp = int(cols[3])

        # velocity
        _veh_dict = vehicle_dict.get(cols[0], {})
        if _veh_dict.get('vel') is None:
            _veh_dict['vel'] = [float(cols[11])]
        else:
            _veh_dict['vel'].append(float(cols[11]))

        # acceleration
        if _veh_dict.get('acc') is None:
            _veh_dict['acc'] = [float(cols[12])]
        else:
            _veh_dict['acc'].append(float(cols[12]))

        # lanes
        if _veh_dict.get('lanes') is None:
            _veh_dict['lanes'] = [int(cols[13])]
        else:
            _veh_dict['lanes'].append(int(cols[13]))

        vehicle_dict[cols[0]] = _veh_dict

    for _veh_id in vehicle_dict.keys():
        vehicle_dict[_veh_id]['vel_mean'] = np.mean(vehicle_dict[_veh_id]['vel'])
        vehicle_dict[_veh_id]['acc_mean'] = np.mean(vehicle_dict[_veh_id]['acc'])

    _veh_vel_means = []
    _veh_acc_means = []
    for _veh_id in vehicle_dict.keys():
        _veh_vel_means.append(vehicle_dict[_veh_id]['vel_mean'])
        _veh_acc_means.append(vehicle_dict[_veh_id]['acc_mean'])
    vehicle_dict['vel_mean'] = np.mean(_veh_vel_means)
    vehicle_dict['acc_mean'] = np.mean(_veh_acc_means)

    return vehicle_dict, start_timestamp, end_timestamp


def get_coeffs():
    coeffs = {}

    coeffs['MEAN_VEL_COEFF'] = 0.1
    coeffs['MEAN_ACC_COEFF'] = 0.1
    coeffs['MEAN_DENSITY_COEFF'] = 0.1
    coeffs['MEAN_PARAM_COEFF'] = 0.9

    return coeffs


def prepare_metrics(client_paths, server_path):
    clients = {
        "vel_mean": [],
        "acc_mean": [],
        "density_mean": [],
        "time_endurance": [],
        "num_of_vehs": []
    }
    server = {}
    server_veh_dict, server_start_time, server_end_time = get_veh_metrics(server_path)
    server_density, server_avg_density = get_density_metric(server_path)
    server["vel_mean"] = server_veh_dict["vel_mean"]
    server["acc_mean"] = server_veh_dict["acc_mean"]
    server["density_mean"] = server_avg_density
    server["time_endurance"] = server_end_time - server_start_time
    server["num_of_vehs"] = len(server_veh_dict.keys())

    for _ind, _path in enumerate(client_paths):
        if isinstance(_path, list):
            _temp_client_veh_dict_li = []
            _temp_client_avg_density_li = []
            _temp_client_total_time = 0
            _temp_client_total_num_vehs = 0
            for _p in _path:
                _temp_client_veh_dict, _temp_client_start_time, _temp_client_end_time = get_veh_metrics(_p)
                _temp_client_density, _temp_client_avg_density = get_density_metric(_p)

                _temp_client_veh_dict_li.append(_temp_client_veh_dict)
                _temp_client_avg_density_li.append(_temp_client_avg_density)
                _temp_client_total_time += (_temp_client_end_time - _temp_client_start_time)
                _temp_client_total_num_vehs += len(_temp_client_veh_dict.keys())

            _temp_client_vel_mean_li = [v["vel_mean"] for v in _temp_client_veh_dict_li]
            _temp_client_acc_mean_li = [v["acc_mean"] for v in _temp_client_veh_dict_li]
            clients["vel_mean"].append(np.mean(_temp_client_vel_mean_li))
            clients["acc_mean"].append(np.mean(_temp_client_acc_mean_li))
            clients["density_mean"].append(np.mean(_temp_client_avg_density_li))
            clients["time_endurance"].append(_temp_client_total_time)
            clients["num_of_vehs"].append(_temp_client_total_num_vehs)
        else:
            _temp_client_veh_dict, _temp_client_start_time, _temp_client_end_time = get_veh_metrics(_path)
            _temp_client_density, _temp_client_avg_density = get_density_metric(_path)
            _temp_client_time = _temp_client_end_time - _temp_client_start_time

            clients["vel_mean"].append(_temp_client_veh_dict["vel_mean"])
            clients["acc_mean"].append(_temp_client_veh_dict["acc_mean"])
            clients["density_mean"].append(_temp_client_avg_density)
            clients["time_endurance"].append(_temp_client_time)
            clients["num_of_vehs"].append(len(_temp_client_veh_dict.keys()))

    return clients, server

def split_area(num_of_splits: int):
    """
    split the x into 10 areas
    split the y into 10 areas
    Args:
        num_of_splits

    Returns:

    """
    return [set() for _ in range(num_of_splits)], [set() for _ in range(num_of_splits)]

def spit_into_areas(path: str):
    assert os.path.exists(path)

    with open(path, 'r') as reader:
        # print(train_file_path)
        content = np.array([x.strip().split(',') for x in reader.readlines()]).astype(float)
        now_dict = {}
        for row in content:
            n_dict = now_dict.get(row[1], {})
            n_dict[row[0]] = row  # [2:]
            now_dict[row[1]] = n_dict

    frame_id_sorted = sorted(now_dict.keys())
    seprated_area_dict = {}
    for _frame_id in frame_id_sorted:
        for _veh_id in now_dict[_frame_id].keys():
            pass




if __name__ == '__main__':

    # trace1 = prepare_trace('1', '1113433143600', '1113433191600', './data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_0-1mins_no_overlap.csv')
    # trace2 = prepare_trace('2', '1113433169200', '1113433196200', './data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_0-1mins_no_overlap.csv')
    # print(generate_dtw_distance(trace1, trace2)[0])

    clients = [
        ['data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_0-1mins_no_overlap.csv',
        'data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_1-2mins_no_overlap.csv',
        'data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_2-3mins_no_overlap.csv']
    ]

    server = 'data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_5-6mins_no_overlap.csv'

    c_metrics, s_metrics = prepare_metrics(clients, server)
