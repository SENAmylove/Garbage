import numpy as np
import pandas as pd
from scipy.spatial import distance
# from fastdtw import fastdtw
from functools import partial
from datetime import datetime
from typing import List, Set, Union
import os


def prepare_trace(id: str, start_time: str, end_time: str, file_path: str) -> np.array:
    assert os.path.exists(file_path)

    _resulted_trace = []

    with open(file_path, 'r') as reader:
        contents = reader.readlines()

    for _line_index, _line in enumerate(contents):
        _cols = _line.split(',')
        _current_id = _cols[0]
        _current_time = _cols[3]
        if int(_line.split(',')[0]) == int(id) and int(_current_time) >= int(start_time) and int(_current_time) <= int(end_time):
            _inserted = np.array([float(_val) for _col_index,_val in enumerate(_cols) if _col_index in [4, 5, 11, 12]])

            if _line_index >= 1:
                _previous_pos = [float(_p) for _p in contents[_line_index-1].split(',')[4:6]]
                _current_pos = [float(_p) for _p in _cols[4:6]]
                _direction = np.array(_current_pos) - np.array(_previous_pos)
                _direction = _direction / np.linalg.norm(_direction)
                _inserted = np.append(_inserted, _direction)
            else:
                _inserted = np.append(_inserted, np.array([0.0,0.0]))

            _resulted_trace.append(_inserted)

    return _resulted_trace


def generate_dtw_distance(trace1: List[Union[float,List[float]]], trace2: List[Union[float,List[float]]]):
    assert len(trace1) > 0
    assert len(trace2) > 0
    def worker(pos1: np.array, pos2: np.array):
        _total_euclidean_distance = 0.0
        _total_euclidean_distance += np.sum((pos1[0:4] - pos2[0:4])**2)
        _total_euclidean_distance += distance.euclidean(pos1[4:], pos2[4:])
        return _total_euclidean_distance
    # prepare two traces
    return fastdtw(trace1, trace2, dist = worker)


def get_density_metric(file_path: str):
    assert os.path.exists(file_path)
    
    with open(file_path, 'r') as reader:
        # print(train_file_path)
        content = np.array([x.strip().split(',') for x in reader.readlines()]).astype(float)
        now_dict = {}
        for row in content:
            n_dict = now_dict.get(row[1], {})
            n_dict[row[0]] = row  # [2:]
            now_dict[row[1]] = n_dict
    density = []
    for _frame_id, _vehs in now_dict.items():
        density.append((_frame_id, len(_vehs)))
    density = sorted(density, key = lambda den: den[0])
    
    avg_density = 0
    for (_frame_id, _den) in density:
        avg_density += _den
    avg_density = avg_density / len(density)
    
    return density, avg_density
    
    
def get_veh_metrics(file_path: str):
    assert os.path.exists(file_path)
    with open(file_path, 'r') as reader:
        contents = reader.readlines()

    vehicle_dict = {}
    start_timestamp = int(contents[0].split(',')[3])
    end_timestamp = start_timestamp
    for _line in contents:
        cols = _line.split(',')
        if int(cols[3]) < start_timestamp:
            start_timestamp = int(cols[3])

        if int(cols[3]) > end_timestamp:
            end_timestamp = int(cols[3])

        # velocity
        _veh_dict = vehicle_dict.get(cols[0], {})
        if _veh_dict.get('vel') is None:
            _veh_dict['vel'] = [float(cols[11])]
        else:
            _veh_dict['vel'].append(float(cols[11]))

        # acceleration
        if _veh_dict.get('acc') is None:
            _veh_dict['acc'] = [float(cols[12])]
        else:
            _veh_dict['acc'].append(float(cols[12]))

        # lanes
        if _veh_dict.get('lanes') is None:
            _veh_dict['lanes'] = [int(cols[13])]
        else:
            _veh_dict['lanes'].append(int(cols[13]))

        vehicle_dict[cols[0]] = _veh_dict

    for _veh_id in vehicle_dict.keys():
        vehicle_dict[_veh_id]['vel_mean'] = np.mean(vehicle_dict[_veh_id]['vel'])
        vehicle_dict[_veh_id]['acc_mean'] = np.mean(vehicle_dict[_veh_id]['acc'])
    
    _veh_vel_means = []
    _veh_acc_means = []
    for _veh_id in vehicle_dict.keys():
        _veh_vel_means.append(vehicle_dict[_veh_id]['vel_mean'])
        _veh_acc_means.append(vehicle_dict[_veh_id]['acc_mean'])
    vehicle_dict['vel_mean'] = np.mean(_veh_vel_means)
    vehicle_dict['vel_acc'] = np.mean(_veh_acc_means)

    return vehicle_dict, start_timestamp, end_timestamp


def get_coeffs():
    coeffs = {}
    
    coeffs['MEAN_VEL_COEFF'] = 0.1
    coeffs['MEAN_ACC_COEFF'] = 0.1
    coeffs['MEAN_DENSITY_COEFF'] = 0.1
    coeffs['MEAN_PARAM_COEFF'] = 0.9
    
    return coeffs
def prepare_metrics(client_paths: list[str], server_path: str):
    clients = {
        "vel_mean": [],
        "acc_mean": [],
        "density_mean": []
    }
    server = {}
    server_veh_dict, _, _ = get_veh_metrics(server_path)
    _, server_avg_density = get_density_metric(server_path)
    server["vel_mean"] = server_veh_dict["vel_mean"]
    server["acc_mean"] = server_veh_dict["acc_mean"] 
    server["density_mean"] = server_avg_density
    
    for _ind, _path in enumerate(client_paths):
        _temp_client_veh_dict, _, _ = get_veh_metrics(_path)
        _, _temp_client_avg_density = get_density_metric(_path)
        clients["vel_mean"][_c] = _temp_client_veh_dict["vel_mean"]
        clients["acc_mean"][_c] = _temp_client_veh_dict["acc_mean"]
        clients["density_mean"][_c] = _temp_client_avg_density
    
    return clients, server
    
    

if __name__ == '__main__':
    veh, start, end = get_veh_metrics('./smoothed_trajectories-0400-0415_deli_downsampled_by_4_0-1mins_no_overlap.csv')
    pass





# if __name__ == '__main__':

#     trace1 = prepare_trace('1', '1113433143600', '1113433191600', './data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_0-1mins_no_overlap.csv')
#     trace2 = prepare_trace('2', '1113433169200', '1113433196200', './data/NGSIM/prediction_train/smoothed_trajectories-0400-0415_deli_downsampled_by_4_0-1mins_no_overlap.csv')
#     print(generate_dtw_distance(trace1, trace2)[0])
